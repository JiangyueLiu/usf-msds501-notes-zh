# 使用 git 版本控制工具

**动机**。 每个商业开发人员都在工作时使用版本控制。 您将遇到的每家公司都使用它。 仅仅因为这个原因，您需要学习版本控制来在商业环境中发挥作用。 在本课程中，您还将使用版本控制（一种名为`git`的系统）来提交您的作品。

对于我们在 MSAN 中的目的，我们将忽略程序员常规使用的大多数非平凡功能，例如分支和合并。 Git 非常复杂，如果没有优秀的`github.com`，它将不是我的首选。

在本实验中，目标是基本了解版本控制和 git / github 的工作原理。 我们将借此机会，通过开始使用图像项目仓库来学习主要的 git 命令。

这是一个互动式[ git “游戏”](https://github.com/git-game/git-game)，来帮助您学习。 网上有很多[课程资料](https://lab.github.com/courses)。

## 版本控制入门

让我绕个弯子，你应该备份你的笔记本电脑。想象一下你的笔记本电脑丢了。 你的所有工作将在哪里？不见了。 我推荐 Carbonite 或 Mozy。 就个人而言，我的计算机旁边有一个本地 Timemachine OS X 备份硬盘，每小时拍摄一次快照。 它跟踪与前一个快照的差异，而不是再次复制整个硬盘驱动器（缓慢/浪费）。 然后，我使用 Carbonite 进行异地云备份，当我晚上睡觉时备份。

使用这种多层备份策略，是思考程序员如何使用版本控制的好方法。 git 有点像 Time Machine，一个本地备份，github.com 有点像 Carbonite 异地云备份。 版本控制系统和备份系统之间的区别在于，我们指示版本控制系统**什么时候生成快照**。 每个快照应该是对文件所做的逻辑工作块。备份系统自动拍摄快照。

我们不仅告诉版本控制系统何时拍摄快照，我们还告诉它**快照是什么**。 您处理的每个项目都在一个目录中，与该项目关联的所有文件都位于该子树中的某个位置。 文件集称为*仓库*，在任何给定时间，我的计算机都有很多这样的存储库。

`git`存储库实例只是磁盘上的一个目录，但它也有一个`.git`（隐藏）目录。 该目录包含一个完整的数据库，其中包含存储库中发生的所有事情，因为它是使用`git init`创建的（或者因为你从 github 克隆了它）。 如果要丢弃存储库，只需从磁盘中删除整个子树。没有通知中央服务器。 每个存储库实例都是一个完整的副本，因此您可以拥有 10 个存储库版本，这些存储库位于不同目录中，从同一磁盘上的原始存储库克隆。

**跟踪变化**

与 Time Machine 备份一样，git 跟踪快照与上次请求快照时的差异。 每个快照都被称为*提交*（并且程序员将这些提交视为*事务*。）您应该请求提交来锁定逻辑工作块，例如功能添加或错误修复。 拥有完整的更改列表非常有用。例如，这是一个块，取自 ANTLR 存储库中我的提交，由 [SourceTree](https://www.sourcetreeapp.com) git GUI 所示：

![commits](img/commits.png)

<img src="img/redbang.png" width=30 align="left">

您可以返回并查看对存储库的任何提交所做的更改。 无论是使用 PyCharm 还是 git，我发现回顾最近的提交来查看哪些更改引入了错误非常重要。 有时我决定放弃一小部分正在做的事情并将文件翻转回旧版本。 如果你走错了路并希望恢复所有这些变化，git 可以很容易地做到这一点。 它甚至可以将存储库重置为某些早期提交的状态。

**github.com 上的镜像仓库**

继续这个类比，github.com 就像我使用的基于云的异地备份。 我们通常会在 github.com 上保留我们本地存储库的完整副本。与提交更改一样，我们还必须将本地存储库*推送*到 github。每次推送都可以确保完整的文件集和 git 更改数据库（在`.git`子目录中）备份到了 Github 上。 当然，作为这样的副作用，您现在拥有了您的工作的备份。 丢失你的笔记本电脑并不是灾难性的，至少就你的工作而言。

使用 github 的原因是我也可以访问你的存储库，而我无法访问你的笔记本电脑硬盘。 为了给项目评分，我将将您的存储库*克隆*到我的硬盘上。 如果你进行了更改，我可以*拉取*那些。我也可以编辑你的代码来发表评论，然后将我的存储库副本*推*回 github，然后你可以将这些更改*拉*回你的硬盘。 一切都是同步的，它不会错误地覆盖更改。 这是多个程序员之间的沟通方式，并且有点超出了这个介绍性的课程，但你至少应该在抽象中意识到这一点。

还有一种情况是，您可以使用 github.com 在两台不同的计算机上处理相同的软件，例如笔记本电脑和台式机。 拥有两台具有相同软件的计算机意味着它们具有副本。 这会使您可能覆盖软件的正确/最新版本。 或者，您会忘记您已经对笔记本电脑进行了更改，但现在已经在桌面上进行了一系列更改。 您在两台不同的计算机上进行了更改 解决问题可能很棘手且容易出错，所以我们`push/pull`到/从 github 来保持同步。

## 图像项目入门

您将收到一个指向 github 的链接，该链接是为图像项目创建存储库的邀请。 在您接受之后，它将为您提供指向私有存储库的链接（只有您和我可以看到存储库的内容）。 我的 github id 是`parrt`，所以我的 URL 是：

```
https://github.com/USF-MSAN501/images-parrt
```

我教的每个课程都将在 github 上拥有自己的组织，在这种情况下：`https://github.com/USF-MSAN501`。每个人在 github 的目录下都有一个存储库，每个项目一个。

我们的第一步是从 github *克隆*空存储库到我们的本地磁盘上。从您的 github 存储库页面，复制 HTTPS URL，如下所示：

<img src=img/github-setup.png width=420>

如果选择 SSH 版本，则需要我们为身份验证设置 SSH 密钥。这是你最后想要做的，但就目前而言，不要担心，只需使用 HTTPS。

**克隆到你的笔记本**

现在，打开终端或其他 bash shell 程序并创建一个目录，该目录将以有序的方式容纳所有 MSAN 项目。 我强烈建议您创建一个整体目录，在该目录下为每个课程创建一个目录。 从命令行看起来像这样：

```bash
$ pwd             # print working directory
/Users/parrt     
$ mkdir classes   # make directory called classes
$ cd classes      # change current working directory to classes
$ mkdir msan501   # create directory msan501 under classes
$ cd msan501      # jump into msan501
```

<img src="img/redbang.png" width=30 align="left">

不要在您创建的任何文件名或目录中使用空格。 许多开源项目是在 UNIX 下开发的，UNIX 讨厌文件名中的空格。 如果你使用空格，东西会神秘地无效。

根据您设置 shell 的方式，您可能会看到`$`提示符左侧的当前工作目录。 这是我的提示符：

```bash
beast:~/classes/msan501 $ 
```

我的机器名称是beast，`~`是`/Users/parrt`的简写或者你的用户 ID。

现在我们有了一个合适的结构，是时候在`/Users/parrt/classes/msan501`下克隆你的存储库了：

```bash
$ git clone https://github.com/USF-MSAN501/images-parrt.git
Cloning into 'images-parrt'...
warning: You appear to have cloned an empty repository.
$ cd images-parrt/
$ ls
```

克隆后，在`msan501`下有一个名为`images-YOURID`的空目录。 您可以在此目录下完成所有工作。**此目录称为存储库**。从技术上讲，它不是空的，如果你在`ls`命令中使用`-a`选项，请求当前目录中的所有文件，你将看到 git 用来存储快照的子目录：

```bash
$ ls -a
./                 ../                .git/
```

**由 git 管理的文件**

After you create a repository at github and clone it locally, you can create all sorts of files under the directory managed by git, but git ignores them until you `add` them. The `add` command is basically notifying the repository that it should care about that file.  You can have whatever other files you want laying around. Git will simply ignore them unless you `add` them.

Download [images-starterkit.ipynb](https://github.com/parrt/msan501/blob/master/projects/images-starterkit.ipynb) from github to your images-YOURID directory and call it `images.ipynb`. The cool kids do download and rename without the browser in one command:

```bash
$ curl -o images.ipynb https://github.com/parrt/msan501/raw/master/projects/images-starterkit.ipynb
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 41311    0 41311    0     0  87895      0 --:--:-- --:--:-- --:--:-- 87895
$ ls
images.ipynb
```

If `curl` isn't installed, use `brew` to install it.


**Taking a snapshot (committing)**

We have a file in the directory but git has no idea it should track it. We have to explicitly add it to revision control:

```bash
$ git add images.ipynb
$ git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   images.ipynb
...
```

At this point, we would be free to add more files or change that file. When we want to make a snapshot, we commit our changes:

```bash
$ git commit -a -m 'initial add'
[master (root-commit) b40aca4] initial add
 1 file changed, 9 insertions(+)
 create mode 100644 images.ipynb
```

The `-m` is the option that indicates a commit message follows on the command line.  You can safely ignore what `-a` means, but make sure you always have it on your commit commands.

Until the commit, the file changes are in a so-called staging area. It's kind of like putting everything in a box (add) and then mailing the box (committing).

**Pushing back to github**

Every time you do a commit, you're making a snapshot of the current state of your files. Git tracks the set of changes per commit and a commit message, which we can retrieve easily:

```bash
$ git log
commit b40aca41ed4b94731a2ec87e9c11a60a1a4ef234
Author: parrt <parrt@cs.usfca.edu>
Date:   Fri Jun 30 12:50:42 2017 -0700

    initial add
```

<img src="img/redbang.png" width=30 align="left">Until you explicitly push back to github, github has no idea that you made changes on your local disk to a repository. Git knows where the original repository came from but it does not automatically push anything to github upon commit. Commit is for the local repository, push is for syncing with a remote repository.  The remote repository is called the *origin*. Use the following command to ask git what it thinks the origin is:

```
$ git remote -v
origin	https://github.com/USF-MSAN501/images-parrt.git (fetch)
origin	https://github.com/USF-MSAN501/images-parrt.git (push)
```

Ok, let's push our changes (we added a file) back to github:

```bash
$ git push origin master
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 408 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:USF-MSAN501/images-parrt.git
 * [new branch]      master -> master
```

There is a lot going on in that message, but if there are no errors, you're good to go. The *master* is what we call a branch and you will always be working in the master branch.

Until you get very comfortable with git and github, you should always verify that your pushes succeed by examining the remote repository at github. Refresh your version of the `https://github.com/USF-MSAN501/images-parrt` URL and it should show file `images.ipynb` (and any others you've pushed). Once you've downloaded, unzipped, `add`ed the [image project images zip](https://github.com/parrt/msan501/blob/master/projects/images-expected-output.zip?raw=true), and pushed back to github, your github page should look like:

<img src="../projects/figures/github-initial-add.png" width="600">

Make sure that all of the files that you want to submit for your projects get properly committed locally and then pushed back to github!
 
**Making changes**

You can make changes and lock them in with another commit. (Make sure use the `-a` option on the `git commit`.)

```bash
...change existing file images.ipynb from jupyter lab...
$ git commit -a -m 'what I did to images notebook'
```

**Deleting files**

Deleting a file tracked by git is also considered a change but you can also explicitly use `git rm` *filename*, which is what I do.

```bash
$ git rm foo.py
$ git commit -a -m 'I do not need foo anymore'
```

**Checking differences with repo**

If you make a change and want to know how it's different from the current repository version, just use diff:

```bash
$ ... tweak images.ipynb ...
$ git diff images.ipynb # kinda sucks with notebooks
...
```

**Reverting**

If you screw up and want to toss out **everything** since the last commit, do a hard reset (make sure you use the `--hard` option):

```bash
$ ... tweak whatever you want ...
$ git reset --hard HEAD
```

This throws out all changes since the last commit. If all you want to do is revert uncommitted changes to a single file, you can run this:

```bash
$ git checkout -- filename
```

I think they call that funny dash-dash option "sparse mode." (whatever. yuck.)

