# 使用 git 版本控制工具

**动机**。 每个商业开发人员都在工作时使用版本控制。 您将遇到的每家公司都使用它。 仅仅因为这个原因，您需要学习版本控制来在商业环境中发挥作用。 在本课程中，您还将使用版本控制（一种名为`git`的系统）来提交您的作品。

对于我们在 MSAN 中的目的，我们将忽略程序员常规使用的大多数非平凡功能，例如分支和合并。 Git 非常复杂，如果没有优秀的`github.com`，它将不是我的首选。

在本实验中，目标是基本了解版本控制和 git / github 的工作原理。 我们将借此机会，通过开始使用图像项目仓库来学习主要的 git 命令。

这是一个互动式[ git “游戏”](https://github.com/git-game/git-game)，来帮助您学习。 网上有很多[课程资料](https://lab.github.com/courses)。

## 版本控制入门

让我绕个弯子，你应该备份你的笔记本电脑。想象一下你的笔记本电脑丢了。 你的所有工作将在哪里？不见了。 我推荐 Carbonite 或 Mozy。 就个人而言，我的计算机旁边有一个本地 Timemachine OS X 备份硬盘，每小时拍摄一次快照。 它跟踪与前一个快照的差异，而不是再次复制整个硬盘驱动器（缓慢/浪费）。 然后，我使用 Carbonite 进行异地云备份，当我晚上睡觉时备份。

使用这种多层备份策略，是思考程序员如何使用版本控制的好方法。 git 有点像 Time Machine，一个本地备份，github.com 有点像 Carbonite 异地云备份。 版本控制系统和备份系统之间的区别在于，我们指示版本控制系统**什么时候生成快照**。 每个快照应该是对文件所做的逻辑工作块。备份系统自动拍摄快照。

我们不仅告诉版本控制系统何时拍摄快照，我们还告诉它**快照是什么**。 您处理的每个项目都在一个目录中，与该项目关联的所有文件都位于该子树中的某个位置。 文件集称为*仓库*，在任何给定时间，我的计算机都有很多这样的存储库。

`git`存储库实例只是磁盘上的一个目录，但它也有一个`.git`（隐藏）目录。 该目录包含一个完整的数据库，其中包含存储库中发生的所有事情，因为它是使用`git init`创建的（或者因为你从 github 克隆了它）。 如果要丢弃存储库，只需从磁盘中删除整个子树。没有通知中央服务器。 每个存储库实例都是一个完整的副本，因此您可以拥有 10 个存储库版本，这些存储库位于不同目录中，从同一磁盘上的原始存储库克隆。

**跟踪变化**

As with the Time Machine backup, git tracks snapshots as the difference from the last time you requested a snapshot.  Each snapshot is called a *commit* (and programmers think of these commits as *transactions*.) You should request a commit to lock in a logical chunk of work, such as the addition of a feature or fixing of a bug. Having a complete list of changes is extremely useful. For example, here is a chunk taken out of the middle of my commits on the ANTLR repository as shown by the [SourceTree](https://www.sourcetreeapp.com) git GUI:

![commits](img/commits.png)

<img src="img/redbang.png" width=30 align="left">You can go back and look at changes made to the repository for any commit. Whether using PyCharm or git, I find it very important to look back at recent commits to see what changes have introduced a bug.  Sometimes I decide to abandon a small piece of what's going on and flip a file back to an old version. If you go down a wrong path and would like to revert all those changes, git can easily do that. It can even reset the repository to the state of some earlier commit.

**Mirroring repositories at github.com**

Continuing with the analogy now, github.com is like the off-site cloud-based backup I use. We will typically keep a complete copy of our local repositories at github.com. As with committing changes, we also have to specifically *push* the local repository to github. Every push ensures that the complete file set and git change database (in .git subdirectory) is mirrored at github.  As a side effect of this, of course, you now have a backup of your work. The loss of your laptop is not catastrophic, at least as far as your coursework is concerned.

The reason to use github is that I can also access your repositories then, whereas I have no access to your laptop hard drive. To grade your projects, I will *clone* your repository onto my hard disk. If you make changes, I can *pull* those in. I might also edit your code to make comments and then *push* my copy of the repository back to github and then you can *pull* those changes back to your hard drive. Everything will be in sync and it will not overwrite changes by mistake. This is how multiple programmers communicate and is a bit beyond this introductory lecture, but you should be aware of this in the abstract at least.

It's also the case that you can use github.com to work on the same software on two different computers, such as a laptop and a desktop.  Having two computers with the same software means they have copies. That introduces the possibility that you will overwrite the correct/latest version of your software. Or, you will forget that you had made changes on your laptop but have now made a bunch of changes on your desktop.  You have changes on two different computers. Resolving things can be tricky and error-prone so we use push/pull to github to keep things in sync.

## Getting started on the images project

You will receive a link to github that is an invitation to create a repository for the images project. After you accept, it will give you a link to the private repository (only you and I can see the contents of the repository). My github id is `parrt` and so my URL is:

```
https://github.com/USF-MSAN501/images-parrt
```

Each class I teach will have be its own organization at github, in this case: `https://github.com/USF-MSAN501`. Each person will have a repository under that directory at github, one per project.

Our first step is to *clone* that empty repository from github onto our local disk. From your repository page and github, copy the HTTPS URL, as shown here:

<img src=img/github-setup.png width=420>

If you choose the SSH version, it will require that we set up SSH keys for authentication. That is what you will ultimately want to do, but for now, don't worry about that and just use HTTPS.

**Cloning onto your laptop**

Now, open the terminal or other bash shell program and create a directory that will house all of your MSAN projects in an orderly fashion. I strongly recommend you create an overall directory under which you create a directory for each class. From the command line it looks like this:

```bash
$ pwd             # print working directory
/Users/parrt     
$ mkdir classes   # make directory called classes
$ cd classes      # change current working directory to classes
$ mkdir msan501   # create directory msan501 under classes
$ cd msan501      # jump into msan501
```

<img src="img/redbang.png" width=30 align="left">Do not use spaces in any filename or directory you ever create. Many open source projects are developed under UNIX and UNIX hates spaces in filenames. Things will mysteriously fail to work if you use spaces.

Depending on how you have your shell set up, you might see the current working directory to the left of the `$` prompt. Here is what my prompt looks like:

```bash
beast:~/classes/msan501 $ 
```

The name of my machine is beast and `~` is shorthand for `/Users/parrt` or whatever your user ID is.
 
Now we have an appropriate structure and it's time to clone your repository under `/Users/parrt/classes/msan501`:

```bash
$ git clone https://github.com/USF-MSAN501/images-parrt.git
Cloning into 'images-parrt'...
warning: You appear to have cloned an empty repository.
$ cd images-parrt/
$ ls
```

After cloning, you have an empty directory under `msan501` called `images-YOURID`. It is under this directory that you will do all of your work. **This directory is called the repository**. Technically it's not empty, if you ask for all files in the current directory with `-a` option on `ls` command, you will see the subdirectory used by git to store snapshots:

```bash
$ ls -a
./                 ../                .git/
```

**Files managed by git**

After you create a repository at github and clone it locally, you can create all sorts of files under the directory managed by git, but git ignores them until you `add` them. The `add` command is basically notifying the repository that it should care about that file.  You can have whatever other files you want laying around. Git will simply ignore them unless you `add` them.

Download [images-starterkit.ipynb](https://github.com/parrt/msan501/blob/master/projects/images-starterkit.ipynb) from github to your images-YOURID directory and call it `images.ipynb`. The cool kids do download and rename without the browser in one command:

```bash
$ curl -o images.ipynb https://github.com/parrt/msan501/raw/master/projects/images-starterkit.ipynb
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 41311    0 41311    0     0  87895      0 --:--:-- --:--:-- --:--:-- 87895
$ ls
images.ipynb
```

If `curl` isn't installed, use `brew` to install it.


**Taking a snapshot (committing)**

We have a file in the directory but git has no idea it should track it. We have to explicitly add it to revision control:

```bash
$ git add images.ipynb
$ git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   images.ipynb
...
```

At this point, we would be free to add more files or change that file. When we want to make a snapshot, we commit our changes:

```bash
$ git commit -a -m 'initial add'
[master (root-commit) b40aca4] initial add
 1 file changed, 9 insertions(+)
 create mode 100644 images.ipynb
```

The `-m` is the option that indicates a commit message follows on the command line.  You can safely ignore what `-a` means, but make sure you always have it on your commit commands.

Until the commit, the file changes are in a so-called staging area. It's kind of like putting everything in a box (add) and then mailing the box (committing).

**Pushing back to github**

Every time you do a commit, you're making a snapshot of the current state of your files. Git tracks the set of changes per commit and a commit message, which we can retrieve easily:

```bash
$ git log
commit b40aca41ed4b94731a2ec87e9c11a60a1a4ef234
Author: parrt <parrt@cs.usfca.edu>
Date:   Fri Jun 30 12:50:42 2017 -0700

    initial add
```

<img src="img/redbang.png" width=30 align="left">Until you explicitly push back to github, github has no idea that you made changes on your local disk to a repository. Git knows where the original repository came from but it does not automatically push anything to github upon commit. Commit is for the local repository, push is for syncing with a remote repository.  The remote repository is called the *origin*. Use the following command to ask git what it thinks the origin is:

```
$ git remote -v
origin	https://github.com/USF-MSAN501/images-parrt.git (fetch)
origin	https://github.com/USF-MSAN501/images-parrt.git (push)
```

Ok, let's push our changes (we added a file) back to github:

```bash
$ git push origin master
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 408 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:USF-MSAN501/images-parrt.git
 * [new branch]      master -> master
```

There is a lot going on in that message, but if there are no errors, you're good to go. The *master* is what we call a branch and you will always be working in the master branch.

Until you get very comfortable with git and github, you should always verify that your pushes succeed by examining the remote repository at github. Refresh your version of the `https://github.com/USF-MSAN501/images-parrt` URL and it should show file `images.ipynb` (and any others you've pushed). Once you've downloaded, unzipped, `add`ed the [image project images zip](https://github.com/parrt/msan501/blob/master/projects/images-expected-output.zip?raw=true), and pushed back to github, your github page should look like:

<img src="../projects/figures/github-initial-add.png" width="600">

Make sure that all of the files that you want to submit for your projects get properly committed locally and then pushed back to github!
 
**Making changes**

You can make changes and lock them in with another commit. (Make sure use the `-a` option on the `git commit`.)

```bash
...change existing file images.ipynb from jupyter lab...
$ git commit -a -m 'what I did to images notebook'
```

**Deleting files**

Deleting a file tracked by git is also considered a change but you can also explicitly use `git rm` *filename*, which is what I do.

```bash
$ git rm foo.py
$ git commit -a -m 'I do not need foo anymore'
```

**Checking differences with repo**

If you make a change and want to know how it's different from the current repository version, just use diff:

```bash
$ ... tweak images.ipynb ...
$ git diff images.ipynb # kinda sucks with notebooks
...
```

**Reverting**

If you screw up and want to toss out **everything** since the last commit, do a hard reset (make sure you use the `--hard` option):

```bash
$ ... tweak whatever you want ...
$ git reset --hard HEAD
```

This throws out all changes since the last commit. If all you want to do is revert uncommitted changes to a single file, you can run this:

```bash
$ git checkout -- filename
```

I think they call that funny dash-dash option "sparse mode." (whatever. yuck.)

