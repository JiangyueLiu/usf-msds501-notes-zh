
# 使用函数组织你的代码

<img src="img/pestle.png" width="75" align="right">

几年前，我学会了从头开始制作泰国红咖喱酱，包括烘烤，然后在巨大的研钵和杵中研磨和捣碎种子。这需要很长时间，所以我一般都会从商店购买现成的咖喱酱。

<img src="img/redcurry.jpeg" width="70" align="right">

类似地，大多数烹饪书提供了许多其他食谱所使用的基本食谱，例如制作调味汁。烹饪书被组织成一系列可执行的食谱，其中一些“调用”其他食谱。 为了做晚餐，我打开一本食谱，获取一些原料，然后按照特定的顺序执行一个或多个食谱。

编写程序的方式也是一样的。打开烹饪书与导入库相同。获取原材料可能意味着将数据加载到内存中。主程序调用函数（食谱）来完成特定任务。作为编写程序的一部分，我们通常会将代码的逻辑部分分解为特定于我们问题的函数，而库中的函数则倾向于广泛适用。

我们组织代码的方式很重要。 如果我们对风格和组织不严格，程序很快就会成为难以理解的老鼠窝。 以下是我们将编写的 Python 程序的一般结构：


+   导入任何库
+   定义任何常量，简单的数据值
+   定义任何函数
+   主程序体

## 作为子程序的函数

分组为单个命名实体的一系列操作称为**函数**。函数就像迷你程序或子程序，我们可以像完整的程序一样规划。

Python **程序**由零个或多个函数和所谓的“主”程序组成，它由让事情开始的一系列操作组成。

函数不从磁盘加载数据，而是操作由调用程序提供给它们的数据。 这个输入数据类似于食谱的成分列表，并以一个或多个命名*形式参数*（或者称为*参数*）的形式指定。函数不像程序那样打印结果或显示图形，而是*返回*值。函数是指广泛有用的辅助例程。

我们通过确定以下内容开始规划函数：
 
1.描述性函数名称
2.它操作的值的类型（参数类型）
3.它返回的值的类型（返回类型）
4.函数做了什么和返回的值

如果我们无法确切地指定函数的内部和外部，那么就没有希望确定处理步骤，更不用说实现该函数了的 Python 代码了。

与程序的工作计划一样，我们手动写出一些示例函数调用，来展示输入数据和输出数据。

一旦我们完全理解了我们的目标，我们就会规划出函数所需的操作顺序，来计算所需的结果。在设计整个程序时，我们从返回值开始，向后工作，以相反的顺序确定操作。注意：操作应该纯粹是数据的函数，数据作为参数传递给它们 -- 函数应该完全不知道任何其他数据。（当我们实际将函数伪代码转换为 Python 时，会有更多相关内容。）

## 函数模板

Python 函数就像黑盒子，通常接受输入数据和并`yield`（或返回）值。每次调用函数都会触发与执行该函数的关联代码，并返回一个或多个结果值。例如，这是一个名为`pi`的函数，它不带参数，但每次调用时返回值`3.14159`：

```python
def pi():
    return 3.14159
```

没有参数的函数的代码模板是：

```py
def funcname():
    statement 1
    statement 2
    ...
    return expression
```

带有函数名称，与函数关联的语句以及描述返回值的表达式的空位。 没有返回值的函数没有`return`语句。

<img src="img/redbang.png" width="30" align="left">

我们将语句与 Python 中的函数关联的方式是缩进。 所以`return 3.14159`是函数的一部分，因为它在函数头之后缩进。与`def`在同一列中的第一个语句是函数外的第一个语句。

```python
def pi():
    return 3.14159
print("this is not part of function")

# this is not part of function
```


<img src="img/redbang.png" width="30" align="left">

*除非我们直接调用该函数，否则 Python 解释器不会执行函数内部的代码。* Python 将函数定义视为：我们可以根据需要调用的“食谱”定义。

函数的*定义*与调用*函数不同。调用函数需要函数名和任何参数值。在这种情况下，我们没有任何参数，所以我们将函数调用为`pi()`：

```python
pi()

# 3.14159
```

```python
pi

# <function __main__.pi()>
```

我们不需要`print`语句，因为我们在笔记本中执行，而不是在 Python 程序中执行。 如果这是在常规 Python 程序中，我们需要一个`print`语句：`print(pi())`，但当然这也适用于此。

每次调用该函数的结果都是`3.14159`。 函数返回一个值但是不打印任何东西。 例如，如果我们将结果赋给变量，则 Jupyter 笔记本或 Python 交互式 shell 不会打印任何内容：

```python
x = pi()
```

我们总是将括号放在函数名旁边，从语法上区分函数和变量。即，`pi`是一个变量引用，但`pi()`是一个函数调用。

某些函数没有返回值，例如在窗口中显示图像的函数。它有改变显示的*副作用*但实际上没有返回值。如果函数没有返回值，则省略`return`语句。这是一个人为的副作用示例，不需要返回值：

```python
def hi():
    print('hi')

hi()

# hi
```


如果你试图使用缺少`return`的函数的值，Python 会给你所谓的`None`值。

```python
x = hi()
print(x)

'''
hi
None
'''
```

当然，我们也可以返回字符串，而不仅仅是数字。 例如，这是一个名为`hello`的函数，它只返回字符串`'hello'`：

```python
def hello():
    return "hello"
```


```python
def parrt():
    return "parrt", 5707

id, phone = parrt()

print(id, phone)

# parrt 5707
```

现在转到更有趣的案例，这里是带有一个参数的函数的模板：

```py
def funcname(argname):
    statement 1
    statement 2
    ...
    return expression
```

如果有两个参数，则函数头如下所示：

```py
def funcname(argname1, argname2):
```

我们作为程序员的工作是，根据我们的函数工作计划，选择函数中的描述性函数名称，参数名称和语句。

**调用带参数的函数**看起来像`funcname(expression)`，`funcname(expression1, expression2)`等等...参数的顺序很重要。Python 将第一个表达式匹配函数定义中给出的第一个参数名称。

让我们看一下[ Python 中的编程模式](python-patterns.ipynb)中的一些代码片段，看看我们是否可以抽象一些有用的函数。

## 求和函数

In [Model of Computation](computation.ipynb), we saw code to translate mathematical Sigma notation to python and so this code to sum the values in a list should be pretty familiar to you:


```python
Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]
sum = 0
for q in Quantity:
    sum = sum + q
sum

# 207
```







This operation is accumulator and there is an associated code template, which you should memorize. Any time somebody says accumulator, you should think loop around a partial result update preceded by initialization of that result.

Summing values is very common so let's encapsulate the functionality in a function to avoid  having to cut-and-paste the code template all the time. Our black box with a few sample "input-output" pairs from a function plan looks like:

<img src="img/sum-func.png" width="180">

(Laying out the examples like that made us realize that we need to worry about empty lists.)

We group the summing functionality into a function by indenting it and then adding a function header:


```python
def sum(data):
    s = 0
    for q in data:
        s = s + q
    return s # return accumulated value s to invoker (this is not a print statement!)

Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]
sum(Quantity) # call sum with a specific list
sum(data=Quantity) # implicit assignment here

# 207
```







The key benefit of this function version is that now we have some generic code that we can invoke with a simple call to `sum`. The argument to the function is the list of data to sum and so the for loop refers to it than the specific `Quantity` variable. (Notice that the variable inside the function is now `s` not `sum` to avoid confusion with the function name.) 


```python
sum([1,2,3])

# 6
```







You might be tempted to build a function that directly references the `Quantity` global list instead of a parameter:

```python
# OMG, this is so horrible I find it difficult to type!
def sum():
    s = 0
    for q in Quantity:
        s = s + q
    return s
```

The problem is this function now only works with one list and is in no way generically useful. This defeats the purpose of creating the function because it's not reusable.
 
Since the real function accepts a list parameter, we can pass another list to the function:


```python
ages = [10, 21, 13]
print(sum(ages))
print(sum([1,3,5,7,9]))
print(sum([ ])) # Empty list

'''
44
25
0
'''
```


Another thing to learn is that Python allows us to name the arguments as we passed them to a function:


```python
sum(data=ages)

# 44
```







The function call, or invocation, `sum(Quantity)` passes the data to the function. The function returns a value and so the function call is considered to evaluate to a value, which we can print out as shown above. Like any value, we can assign the result of calling a function to a variable:


```python
x = sum(Quantity)  # call sum and save result in x
x

# 207
```







Please remember that returning a value from a function is not the same thing as printing, which is a side-effect. Only the `print` statement prints a value to the console when running a program. *Don't confuse executing a program with the interactive Python console (or this notebook), which automatically prints out the value of each expression we type.* For example:

```python
>>> 34
34
>>> 34+100
134
>>> 
```

The `sum` function has one parameter but it's also common to have functions with two parameters.

### Exercise

Write a function called `neg` that takes one number parameter `x` and returns the negative of `x`.


```python
def neg(x): return -x
```

### Exercise

Write a function called `add` the takes 2 number parameters, `x` and `y`, and returns the addition of the two parameters.


```python
def max(x,y): return x if x>y else y

#same as:
#if x>y: return x
#else: return y

# test it
print(max(10,99))
print(max(99,10))

'''
99
99
'''
```


Notice that once we use the argument names, the order does not matter:


```python
print(max(x=10, y=99))
print(max(y=99, x=10))

'''
99
99
'''
```

### Exercise

Write a function called `area` that takes a radius `r` parameter and returns the area of a circle with that radius (&pi;`r`<sup>2</sup>). Hint: Recall that the `math` package has a variable called `pi`.


```python
import math
def area(r): return math.pi * r**2  # ** is the power operator

# test it
area(1), area(r=2)

# (3.141592653589793, 12.566370614359172)
```


### Exercise

Write a Python function called `words` that accepts a string, `doc`, containing a sequence of words separated by a single space character and returns a list of words in lowercase. An argument of `'X Y z'` should return a list with value `['x', 'y', 'z']`. Hint: `'HI'.lower()` evaluates to `'hi'`.


```python
def words(doc:str) -> list:
    words = doc.split(' ')
    return [w.lower() for w in words]

# OR

def words(doc):
    doc = doc.lower()
    return doc.split(' ')

# OR

def words(doc): return doc.lower().split(' ')

words('Terence Parr is the instructor of MSAN501')

# ['terence', 'parr', 'is', 'the', 'instructor', 'of', 'msan501']
```







## Search function

We've seen code to search for a list element, but the specific element and specific list were *hardcoded*.  That is to say, the code only worked with specific values and was not generic:


```python
first=['Xue', 'Mary', 'Robert']     # our given input
target = 'Mary'                     # searching for Mary
index = -1
for i in range(len(first)):         # i is in range [0..n-1] or [0..n)
    if first[i]==target:
        index = i
        break
index

# 1
```







It would be nice to have a function we can call because searching is so common. To get started, we can just wrap the logic associated with searching in a function by indenting and adding a function header. But, we should also change the name of the list so that it is more generic and make it a parameter (same with the search target).


```python
def search(x, data):
    index = -1
    for i in range(len(data)):         # i is in range [0..n-1] or [0..n)
        if data[i]==x:
            index = i
            break
    print(index)

first=['Xue', 'Mary', 'Robert']
search('Mary', first) # invoke search with 2 parameters
```

    1
    

We are now passing two arguments to the function: `x` is the element to find and `data` is the list to search. Anytime we want, we can search a list for an element just by calling `search`:


```python
search('Xue', first), search('Robert', first)

'''
0
2

(None, None)
'''
```



```python
# It is a good idea to test the failure case
search('Jim', first)

# -1
```


It turns out we can simplify that function by replacing the `break` statement with a `return` statement. Whereas a break statement breaks out of the immediately enclosing loop, the return statement returns from the function no matter where it appears in the function. In the current version, if we find the element, the `break` statement breaks out of the loop and forces the processor to execute the statement following the loop, which is the `return` statement. Because the return statement takes an expression argument, we don't need to track the index in a separate variable. *The `return` statement forces the processor to immediately exit the function and return the specified value.* In effect, then the `return` breaks out of the loop first then the function.

Here is the way the cool kids would write that function:


```python
def search(x, data):
    for i in range(len(data)):  # i is in range [0..n-1] or [0..n)
        if data[i]==x:
            return i            # found element, return the current index i
    return -1                   # failure case; we did not return from inside loop

print(search('Mary', first))
print(search('Xue', first))
print(search('foo', first))

'''
1
0
-1
'''
```


## Visibility of symbols

Variables created outside of a function are so-called *global variables* because they live in the global space (or frame). For example, let's revisit the non-function version of the sum accumulator where I have added a call to lolviz library to display three global variables inside the loop:


```python
from lolviz import *

Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]
sum = 0
display(callviz(varnames=['Quantity','sum','q']))
for q in Quantity:
    sum = sum + q
display(callviz(varnames=['Quantity','sum','q']))
sum

# 207
```


![svg](img/2.6_functions_55_0.svg)



![svg](img/2.6_functions_55_1.svg)








There are three (global) variables here: `Quantity`, `sum`, and `q`. The program uses all of those to compute the result.

Let's see what the "call stack" looks like using the function version of the accumulator.


```python
reset -f
```


```python
from lolviz import *
Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]

def sum(data):
    s = 0
    display(callsviz(varnames=['Quantity','data','s']))
    for q in data:
        s = s + q
    return s

sum(Quantity)

# 207
```


![svg](img/2.6_functions_58_0.svg)









```python

```

As you can see, there is a new *scope* for the `sum` function because the main program invoked a function. That function has a parameter called `data` and a local variable called `s` (from where I have called the `callsviz` function).  Notice that both `Quantity` and `data` variables point at the same shared memory location!! It's just that the names are defined in different contexts (scopes). This is the aliasing of data we talked about in the last section. By traversing `data`, the `sum` function is actually traversing the `Quantity` list from the outer context. 

### Watch out for functions modifying data arguments


```python
def badsum(data):
    #data = data.copy() # must manually make copy to avoid side-effect
    data[0] = 99
    display(callsviz(varnames=['Quantity','data','s']))
    s = 0
    for q in data:
        s = s + q
    return s

Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]
badsum(Quantity)
print(Quantity)

# [99, 49, 27, 30, 19, 21, 12, 22, 21]
```


![svg](img/2.6_functions_62_0.svg)



When the function returns, the frame for `sum` disappears, leaving only the global frame.


```python
def sum(data):
    s = 0
    for q in data:
        s = s + q
    return s

print(sum(Quantity))
callsviz(varnames=['Quantity','data','s'])

# 207
```





![svg](img/2.6_functions_64_1.svg)




```python
reset -f
```


```python
from lolviz import *
def f(x):
    q = 0
    g(x)
    print("back from g")
    display(callsviz(varnames=['x','q','y','z']))
    
def g(y):
    print(y)
    display(callsviz(varnames=['x','q','y','z']))

z = 99
f(33)
print("back from f")
display(callsviz(varnames=['x','q','y','z']))

# 33

# back from g

# back from f
```



![svg](img/2.6_functions_66_1.svg)




![svg](img/2.6_functions_66_3.svg)




![svg](img/2.6_functions_66_5.svg)


### Visibility rules

Now that you have the idea of context in mind, let's establish some rules for the visibility of variables according to context:

* Main programs cannot see variables and arguments inside functions; just because a main program can call a function, doesn't mean it can see the inner workings. Think of functions as black boxes that take parameters and return values.
* Functions can technically see global variables but don't do this as a general rule.  Pass the global variables that you need to each function as arguments.

The latter rule is a good one because violating it generally means you're doing something "wrong". For example, if we tweak the `sum` accumulator function to refer directly to the global variable `Quantity`, we get:

```python
Quantity = [6, 49, 27, 30, 19, 21, 12, 22, 21]
def sum(data):         # parameter not used!
    s = 0
    for q in Quantity: # uh oh!
        s = s + q
    return s
```

The problem is that, now, `sum` only works on that global data. It's not generically useful. The clue is that the function ignores the `data` argument. So, technically the function can see global data, but it's not a good idea. (Violating this rule to alter a global variable is also a good way to get a subtle bug that's difficult to find.)

### Technically we need to see global symbols (functions)


```python
def f():
    g()
    
def g():
    print("hi mom!")
    
f()

# hi mom!
```


## Return values versus printing

Just to pound this concept into your heads...

One of the big confusion points for students is the difference between return values and printing results. We'll look at this again when we translate plans to Python code, but it's important to understand this difference right away. 

Programs in the analytics world typically read data from a file and emit output or write data to another file. In other words, programs interact with the world outside of the program.  The world outside of the program is usually the network, the disk, or the screen.  In contrast, most functions that we write won't interact with the outside world.  

<img src="img/redbang.png" width="30" align="left">Functions compute and return (give values back) to their caller. They don't print anything to the user unless explicitly asked to do so with a `print` statement.  


```python
def pi():
    print(3.14159) # This is not a return statement!
    
print(pi())

'''
3.14159
None
'''
```

