
# 加载文件

本讲座的目的是学习如何从笔记本电脑磁盘上的文件中提取数据。 我们将加载文本文件中的单词和数据文件中的数字。 在此过程中，我们将了解文件名和文件路径的更多信息。 我们的通用分析程序模板的前两个元素，表示获取数据然后将其加载到数据结构中：

1. 获取数据，这意味着找到合适的文件，或从 Web 收集数据并存储在文件中
2. 从磁盘加载数据并放入组织成数据结构的内存中

目前，我们只需手动从网上下载现成的数据文件，即可满足第一步。在[ MSAN692 - 数据采集](https://github.com/parrt/msan692)中，我们将学习如何以编程方式从 Web 提取数据。 本讲座重点介绍分析程序模板的第二步。

随着我们继续，我将反复要求你输入一些这样的例子。 了解从文件加载数据的代码模式至关重要。 请输入您的代码，不要剪切和粘贴。

## 什么是文件

正如我们之前所讨论的，磁盘和 RAM 都是内存的形式。 RAM 比磁盘快得多（但更小）但是当电源耗尽时 RAM 全部消失。 另一方面，磁盘是持久的。 文件只是由文件名标识的，磁盘上的一大块数据。 您一直使用文件。例如，我们可以双击文本文件或 Excel 文件，这将打开一个应用程序来显示这些文件。

我们需要能够编写从文件中读取数据的 Python 程序，就像 Excel 那样。 在 Python 程序中访问 RAM 中的数据非常容易，我们只需使用索引来引用列表中的各种元素，例如`names [i]`。 访问文件数据不太方便，因为我们必须首先将文件显式加载到工作内存中。 例如，我们可能希望将文件中的名称列表加载到`names`列表中。

**如果文件太大而无法同时放入内存，我们必须以块的形式处理数据。**现在，让我们假设所有文件都适合内存。

即便如此，访问文件也有点麻烦，因为我们必须明确地让 Python 打开一个文件，然后（通常）在我们完成后关闭它。 我们还必须区分对文件的读取和写入，这决定了我们打开文件的模式。 我们可以在读，写或追加模式下打开文件。 对于本实验，我们只关注“打开文件来读取”的默认情况。 以下是在读取模式（默认）下打开一个名为`foo.txt`的文件，然后立即关闭该文件的方式：

```
f = open('foo.txt')  # open for read mode
f.close()            # ok, we're done
```

嗯......从`open()`返回什么样的对象并存储在`f`中？ 为什么我们要关闭文件？

## 文件描述符

当我们打开文件时，Python 为我们提供了一个“文件对象”，它实际上只是操作系统为我们提供的句柄或描述符。 它是一个唯一的标识符，以及操作系统识别我们使用的文件的方式。 **文件对象不是文件名，也不是磁盘上的文件本身。**它实际上只是一个描述符和文件的引用。

我们将使用文件名来使用`open()`获取文件对象，并使用文件对象来获取文件内容。

```python
f = open("data/prices.txt") # or just "prices.txt"
print(type(f))
print(f)
f.close()
print(f.closed)

'''
<class '_io.TextIOWrapper'>
<_io.TextIOWrapper name='data/prices.txt' mode='r' encoding='UTF-8'>
True
'''
```

（将`TextIOWrapper`看作*文件*。）

关闭操作通知操作系统您不再需要该资源。 操作系统一次只能打开这么多文件，因此您应该在使用完毕后关闭文件。

稍后，当您学习将数据写入文件时，关闭操作也很重要。 关闭文件会刷新内存缓冲区中的，需要写入的所有数据。 从Python文档：

> “编写程序的一个常见的错误是，你使用代码将所需的所有数据添加到文件中，但程序最终不会创建文件。通常这意味着你忘了关闭文件。”

<img src="img/redbang.png" width="30" align="left"> 

为了避免混淆，请记住这个比喻。 您的房屋内容（文件）与您的地址（文件名）不同，并且与写有地址的文件（文件描述符）不同。进一步来说：

1. 文件名是一个标识磁盘上文件的字符串。 它可以是完全限定的或相对于当前工作目录。

2. 文件对象不是文件名，也不是磁盘上的文件本身。 它实际上只是一个描述符和文件的引用。

3. 文件的内容不同于 Python 给我们的文件名和文件对象（描述符）。

### Python WITH 语句

更新版本的 Python 提供了一种很好的机制来避免忘记文件关闭操作。 `with`语句更通用，但我们只是用它来自动关闭文件。 即使`with`语句中有强制程序终止的异常，关闭操作也会发生。 这是使用方式：

```python
with open("data/prices.txt") as f:
    contents = f.read()
    print(type(contents))
print(contents[0:10])
print(f.closed)

'''
<class 'str'>
0.605
0.60
True
'''
```

## 文件名称和路径

You know what a file name is because you've created lots of files before. (BTW, another reminder not to use spaces in your file or directory names.) *Paths* are unique specifiers or locators for directories or files. A *fully-qualified* filename gives a description of the directories from the root of the file system, separated by `/`. The root of the file system is identified with `/` (forward slash) at the start of a pathname. You are probably used to seeing it as "Macintosh HD" but from a programming point of view, it's just `/`. On Windows, which we will not consider here, the root includes the drive specification and a backslash like `C:\`. Here's a useful diagram showing the components of a fully qualified pathname to a file called `view.py`:

<img src="img/path-names.png" width="750">

As a shorthand, you can start a path with `~`, which means "my home directory". On a Mac that's `/Users/parrt` or whatever your user ID is. On Linux, it's probably `/home/parrt`.

The last element in a path is either a filename or a directory. For example to refer to the directory holding `view.py` in the above diagram, use path `/Users/parrt/classes/msan501/images-parrt`. Or, using the shortcut, the fully qualified path is `~/classes/msan501/images-parrt`. Here's an example bash session that uses some fully qualified paths:

```bash
$ ls /Users/parrt/classes/msan501/images-parrt/view.py
/Users/parrt/classes/msan501/images-parrt/view.py
$ cd /Users/parrt/classes/msan501/images-parrt $ pwd
/Users/parrt/classes/msan501/images-parrt
$ cd ~/classes/msan501/images-parrt
$ pwd
/Users/parrt/classes/msan501/images-parrt
```

### Current working directory

All programs run with the notion of a *current working directory*. So, if a program is running inside the directory `~/classes/msan501/images-parrt`, then the program could refer to any data files sitting in that directory with just a file name--no path is required.  For example, let's use the `ls` program to demonstrate the different kinds of paths.

```bash
$ cd ~/classes/msan501/images-parrt
$ ls
view.py
$ ls /Users/parrt/classes/msan501
images-parrt/
$ ls /Users/parrt/classes
msan501/
```

Any path that does not start with `~` or `/` is called a *relative pathname*. For completeness, note that `..` means the directory above the current working directory:

```bash
$ cd ~/classes/msan501/images-parrt
$ ls ..
images-parrt/
$ ls ../..
msan501/
```

Sometimes you will see me use `/tmp`, which is a temporary directory or dumping ground.  All files in that directory are usually erased when you reboot.

## Loading text files

As we discussed early in the semester, files are just bits. It's how we interpret the bits that is meaningful. The bits could represent an image, a movie, an article, data, Python program text, whatever. Let's call any file containing characters a *text file* and anything else a *binary file*.

Text files are usually 1 byte per character (8 bits) and have the notion of a line. A line is just a sequence of characters terminated with either `\r\n` (Windows) or `\n` (UNIX, Mac). A text file is usually then a sequence of lines. Download this sample text file, [IntroIstanbul.txt](https://raw.githubusercontent.com/parrt/msan501/master/notes/data/IntroIstanbul.txt) so we have something to work with. You can save it in `/tmp` or whatever directory you are using for in class work. For the purposes of this discussion, I have data files in a subdirectory called `data` of this notes directory.

The first 10 lines of the file look like:


```python
! head -10 data/IntroIstanbul.txt

'''
The City and ITS People
Istanbul is one of the worlds most venerable cities. Part
of the citys allure is its setting, where Europe faces Asia acr­oss
the winding turquoise waters of the Bosphorus, making it the only city
in the world to bridge two continents.
'''
```








You can ignore the "`!`" on the front as it is just telling this Jupyter notebook to run the terminal command that follows. If you want you can think of `!` as the `$` terminal prompt in this context.

Now, let's examine the contents of the file in a raw fashion rather than with a text editor. The `od` command (octal dump) is useful for looking at the bytes of the file. Use option `-c` to see the contents as 1-byte characters:


```python
! od -c data/IntroIstanbul.txt | head -5

'''
0000000   \n          \n          \n                  \n                
0000020           \n                                   T   h   e       C
0000040    i   t   y       a   n   d       I   T   S       P   e   o   p
0000060    l   e  \n                                   I   s   t   a   n
0000100    b   u   l       i   s       o   n   e       o   f       t   h
'''
```


That "`| head -5`" *pipes* (the vertical bar "`|`" looks like a pipe) the output of the `od` command to the `head` program, which gives this the first five lines of the output. When we have a lot of output we can also pipe the output to the `more` program to paginate long output.

```bash
$ od -c data/IntroIstanbul.txt | more
...
```

The `\n` character you see represents the single character we know as the carriage return. The numbers on the left are the character offsets into the file (it looks like they are octal not decimal, btw; use `-A d` to get decimal addresses).

Let's look at some common programming patterns dealing with text files.

### Pattern: Load all file contents into a string.

The sequence of operation is open, load, close.


```python
with open('data/IntroIstanbul.txt') as f:
    contents = f.read() # read all content of the file
print(contents[0:200]) # print just the first 200 characters

'''
The City and ITS People
Istanbul is one of the worlds most venerable cities. Part
of the citys allure is its setting, where Europe faces Asia acr­oss
'''
```









### Exercise

*Without cutting and pasting*, type in that sequence and make sure you can print the contents of the file from Python. Instead of `data`, use whatever directory you saved that IntroIstanbul.txt in.

### Pattern: Load all words of file into a list.

This pattern is just an extension of the previous where we `split()` on the space character to get a list:


```python
with open('data/IntroIstanbul.txt') as f:
contents = f.read() # read all content of the file
words = contents.split(' ')
print(words[0:100]) # print first 100 words

# ['\n', '', '\n', '', '\n', '', '', '', '\n', '', '', '', '', '', '\n', '', '', '', '', '', '', '', 'The', 'City', 'and', 'ITS', 'People\n', '', '', '', '', '', '', '', 'Istanbul', 'is', 'one', 'of', 'the', 'worlds', 'most', 'venerable', 'cities.', 'Part\n', '', '', '', '', '', '', '', 'of', 'the', 'citys', 'allure', 'is', 'its', 'setting,', 'where', 'Europe', 'faces', 'Asia', 'acr\xadoss\n', '', '', '', '', '', '', '', 'the', 'winding', 'turquoise', 'waters', 'of', 'the', 'Bosphorus,', 'making', 'it', 'the', 'only', 'city\n', '', '', '', '', '', '', '', 'in', 'the', 'world', 'to', 'bridge', 'two', 'continents.\n', '', '', '', '']
```




Because we are splitting on the space character, newlines and multiple space characters in a row yield "words" that are not useful. We need to transform that list into a new list before it is useful.

### Exercise

Using the *filter* programming pattern filters `words` for only those words greater than 1 character; place into another list called `words2`. Hint `len(s)` gets the length of string `s`. [[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

### Exercise

Put all of this together by writing a function called `getwords` that takes `filename` as a parameter and returns the list of words greater than one character long. This is a combination of the "load all words of the file into a list" pattern and the previous exercise. [[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

## Loading all lines of a file

Reading the contents of a file into a string is not always that useful. We typically want to deal with the words, as we just saw, or the lines of a text file.  Natural language processing (NLP) would focus on using the words, but let's look at some data files, which typically structure files as lines of data.  Each line represents an observation, data point, or record. 

We could split the text contents by `\n` to get the lines, but it is so common that Python provides functions to do that for us. To give us some data to play with, download [prices.txt](https://raw.githubusercontent.com/parrt/msan501/master/notes/data/prices.txt) that has a list of prices, one price per line. Here's another very common programming pattern:

### Pattern: Read all of the lines of the file into a list.

The sequence is open, read lines, close:


```python
with open('data/prices.txt') as f:
    prices = f.readlines() # get lines of file into a list
prices[0:10]

'''
['0.605\n',
 '0.600\n',
 '0.594\n',
 '0.592\n',
 '0.600\n',
 '0.616\n',
 '0.623\n',
 '0.628\n',
 '0.630\n',
 '0.629\n']
'''
```







### Exercise

*Without cutting and pasting*, type in that code and make sure you can read the lines of the file into a list. 

### Exercise

Use the `strip()` function on each element of the list so that you get: `['0.605', '0.600', '0.594', ...]`. Use a list comprehension to *map* the prices to a new version of the prices list. [[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

### Converting list of strings to numpy array

The numbers have the `\n` character on the end but that's not a problem because we can easily convert that using [NumPy](http://www.numpy.org/):


```python
import numpy as np
prices2 = np.array(prices, dtype=float) # convert to array of numbers
print(type(prices2))
print(prices2[0:10])

from lolviz import *
objviz(prices2)

'''
<class 'numpy.ndarray'>
[0.605 0.6   0.594 0.592 0.6   0.616 0.623 0.628 0.63  0.629]
'''
```





![svg](img/3.1_files_26_1.svg)



### Exercise

Add this conversion to the previous exercise and make sure you get an `array` as output.  (I'm trying to give you repeated experience typing code that reads data from a file and processes it in some way.) [[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

## Loading CSV files

Let's look at a more complicated data file. Download [heights.csv](https://raw.githubusercontent.com/parrt/msan501/master/notes/data/player-heights.csv), which starts out like this:


```python
! head -4 data/player-heights.csv

'''
Football height, Basketball height
6.329999924, 6.079999924
6.5, 6.579999924
6.5, 6.25
'''
```

It is still a text file, but now we start to get the idea that text files can follow a particular format. In this case, we recognize it as a *comma-separated value* (CSV) file. It also has a header line that names the columns, which means we need to treat the first line differently than the remainder of the file.

### Pattern: Load a CSV file into a list of lists

We already know how to open a file and get the lines, so let's do that and also separate the lines into the header and the data components:


```python
import numpy as np

with open('data/player-heights.csv') as f:
    lines = f.readlines()

lines = [line.strip() for line in lines] # remove \n on end
lines[0:5]

'''
['Football height, Basketball height',
 '6.329999924, 6.079999924',
 '6.5, 6.579999924',
 '6.5, 6.25',
 '6.25, 6.579999924']
'''
```








```python
header = lines[0]
data = lines[1:] # slice

# print it back out

print(header)
for d in data[0:5]:
    print(d)
    
'''
Football height, Basketball height
6.329999924, 6.079999924
6.5, 6.579999924
6.5, 6.25
6.25, 6.579999924
6.5, 6.25
'''
```


### Exercise

As an exercise, type in that code and make sure you get the header and the first five lines of data printed out.

### Exercise

Each row of the data is a string with two numbers in it. We need to convert that string into a list with two floating-point numbers using `split(',')`.  Combining all of those two-element lists into an overall list gives us the two-dimensional table we need, which is our next exercise.

Write a function called `getcsv(filename)` that returns a list of row lists, where the first row is the header row. Strip off any `\n` char on the end of lines. The output should look like:

```python
[['6.329999924', ' 6.079999924'], ['6.5', ' 6.579999924'], ['6.5', ' 6.25']]
```

Use list comprehensions where you can. [[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

### Exercise

`import pandas as pd` and then convert the data from the previous exercise into a data frame. Pandas doesn't automatically understand that the first row is the header so slice out `data[1:]` as the first argument to the `pd.DataFrame()` data frame constructor and then pass `data[0]` as the `columns` parameter. Print it out and you should see something like:

```
   Football height  Basketball height
0      6.329999924        6.079999924
1              6.5        6.579999924
2              6.5               6.25
...
```

[[solutions](https://github.com/parrt/msan501/blob/master/notes/code/files.py)]

## Using Pandas to load CSV files

Of course, loading CSV is something that data scientists need to do all of the time and so there is a simple function you can use from [Pandas](http://pandas.pydata.org),  another library you will probably become very familiar with:


```python
import pandas as pd
prices = pd.read_csv('data/prices.txt', header=None)
prices.head(5)
```

| | 0 |
| --- | --- |
| 0 | 0.605 |
| 1 | 0.600 |
| 2 | 0.594 |
| 3 | 0.592 |
| 4 | 0.600 |

(`header=None` indicates that there are no column names in the first line of the file.)

This even works for CSV files with header rows:


```python
data = pd.read_csv('data/player-heights.csv')
data.head(5)
```


|  | Football height | Basketball height |
| --- | --- | --- |
| 0 | 6.33 | 6.08 |
| 1 | 6.50 | 6.58 |
| 2 | 6.50 | 6.25 |
| 3 | 6.25 | 6.58 |
| 4 | 6.50 |  |

We'll see this stuff again in [data frames](dataframes.ipynb).

## Processing files line by line

The previous mechanism for getting lines of text into memory works well except that it requires we load everything into memory all at once. That is pretty inefficient and limits the size of the data we can process to the amount of memory we have.

### Pattern: Read data line by line not all at once.

We can use a for-each loop where the sequence of data is the file descriptor:

```python
with open('data/prices.txt') as f:
    for line in f: # for each line in the file
        print(float(line)) # process the line in some way
```


```python
n = 5
with open('data/prices.txt') as f:
    for line in f: # for each line in the file
        if n>0:
            print(float(line)) # process the line in some way
        n -= 1
        
'''
0.605
0.6
0.594
0.592
0.6
'''
```


### Exercise

Type in this new version of processing the lines of the file. No cutting and pasting!

### Exercise

Creative a function called `getsum` that takes a filename string as a parameter and returns the sum of values from the lines in that file. Do not use the `readlines()` function. Use a `for line in f` type loop inside a list comprehensionTo manually get the list of lines. Call `getsum` with filename `data/prices.txt` and print out the sum of prices. Use `sum(...)` to total the list created by your list comprehension.

## Operations after closing the file

Keep in mind that once you close the file, you cannot read anymore data from it:


```python
f = open('data/prices.txt')
f.close()
f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file
```

## Summary

The key programming patterns to take away from this lecture are:

* **Pattern**: Load all file contents into a string.
* **Pattern**: Load all words of file into a list.
* **Pattern**: Read all of the lines of the file into a list.
* **Pattern**: Load list of numbers into a numpy array.
* **Pattern**: Load a CSV file into a 2D numpy array.

You should be able to code those patterns quickly and easily, and without cutting and pasting from stackoverflow.
